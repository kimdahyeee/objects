## 오브젝트_코드로 이해하는 객체지향 설계 예제 코드

### chapter1. 티켓 판매 애플리케이션 구현하기
- 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다.
- 훌륭한 객체지향 설계의 핵심은 **캡슐화**를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.
- 변경하기 쉬운 설계는 **한 번에 하나의 클래스**만 변경할 수 있는 설계다.

### chapter2. 객체지향 프로그래밍
- **객체 지향 프로그래밍을 하며 집중해야할 것 두 가지**
  1. 어떤 클래스가 필요한지를 고민하기 전에 **어떤 객체**들이 필요한지 고민하자.
     - 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
  2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 **협력**하는 공동체의 일원으로 봐야 한다.
     - 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.

- 객체의 변경을 관리할 수 있는 기법 중에서 가장 대표적인 것이 **접근 제어**다.
  - 객체 내부에 대한 접근을 **통제**하는 이유는 객체를 **자율**적인 존재로 만들기 위해서다.
- 객체가 **단 하나의 인스턴스 변수만 포함**하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 **명확성과 유연성**을 높이는 첫걸음이다.

- **다형성**이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
  - `interface` : 구현의 고려 없이 다형적인 협력에 참여하는 경우
  - `abstract class` : **상속**을 통해 다형적인 협력 참여 (공통된 로직을 공유하는 경우)
  
> 💡 유연성이 필요한 곳에 **추상화**를 사용하라

- `Movie` 는 **합성** (인스턴스 변수로 포함해서 재사용)을 이용해 코드를 재사용한다.

### chapter3. 역할, 책임, 협력
> 💡 객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력이다.
- **협력**은 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용이다.
- **책임**은 객체가 다른 객체와 협력하기 위해 수행하는 행동이다.
- **역할**은 다른 것으로 교체할 수 있는 **책임**의 집합이다.
  - **역할**을 이용하면 불필요한 중복 코드를 제거할 수 있다. AND 협력이 더 유연해진다 !
- **추상화**를 사용하면 좋은 점
  - **추상화**를 적절하게 사용하면 불필요한 세부 사항을 생략하고 핵심적인 개념을 강조할 수 있다.
  - **추상화**는 설계를 유연하게 만들 수 있다. 협력안에서 동일한 책임을 수행하는 객체들은 동일한 역할을 수행하기 때문에 대체 가능하기 때문이다.

> 💡 행동에 집중해라. 상태(데이터 주도 설계)에 초점을 맞추게되면 캡슐화를 저해하게 된다.

> 💡 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 **캡슐화**하는 것이다.

### chapter4. 설계 품질과 트레이드오프
> 💡 훌륭한 객체지향 설계는 데이터가 아니라 **책임**에 초점을 맞춰야 한다.
> 이유는 **변경**과 관련이 있다. **좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.**

**캡슐화**
- 캡슐화는 변경 가능성이 높은 부분을 객체 내부로 숨기는 **추상화 기법**이다.
- 시스템이 완전히 캡슐화된다면 우리는 변경으로부터 완전히 자유로워질 것이다.
- 캡슐화 위반의 example
    - `getter`, `setter`의 사용 👉 객체가 자신의 책임을 다하지 않는다는 것
        - 코드 중복이 발생할 확률이 높아진다.
        - 변경에 취약해진다.
    - 데이터 뿐 아니라, 내부 구현의 변경에 의해 외부 객체가 영향을 받는 모든 것

**응집도와 결합도**
- 높은 응집도와 낮은 결합도를 가진 설계를 추구해야한다.
- 낮은 응집도 example
    - 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 아무 상관이 없는 코드들이 영향을 받게 된다.
    - 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.
    - 위의 두가지 이유는 리팩토링 사유가 될 것이다🙂

> 💡 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 **외부**에 맞춰져 있어야 한다.
>중요한 것은 다른 객체와 **협력**하는 방법이다.

### chapter5. 책임 할당하기
> 💡 데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 데이터가 아닌 **책임**에 초점을 맞추는 것이다.

- **책임 중심의 설계를 하기 위해서는 메시지를 결정한 후에 객체를 선택해야 한다.**
    1. "이 객체가 수행해야 하는 책임은 무엇인가"를 먼저 결정하자
    2. "이 책임을 수행하는 데 필요한 데이터는 무엇인가" 를 결정한다.
- 책임을 할당할 수 있는 다양한 대안들이 존재한다면 **응집도와 결합도 측면에서 더 나은 대안**을 선택하자

> 💡 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다.
- 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
  - 일부만 초기화하고 일부는 초기화하지 않은 상태로 남겨둔다는 것은 응집도가 낮다는 말이다.
    
  👉 함께 초기화되는 속성을 기준으로 코드를 분리하자.
- 메서드들이 인스턴스 변수를 사용하는 방식을 확인하자
  - 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다. 
  
  👉 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리하자.
  
> 💡 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하라.
>  절차형 코드로 실행되는 프로그램을 빠르게 작성한 후 완성된 코드를 객체지향적인 코드로 변경하라.
>
> 아무것도 없는 상태에서 책임과 협력에 대해 고민하기 보다는 일단 실행되는 코드를 얻고 난 후에 코드 상에 명확하게
>드러나는 책임들을 올바른 위치로 이동시키자.

**메서드는 작은 메스드로 분리하자.**
- 이해하기 쉬워진다.
- 고수준의 메소드를 볼 때 일련의 주석을 읽는 것 같은 느낌이 들게 할 수 있다.
- 잘게 나누어져 있으면 다른 메서드에서 사용할 확률이 높아진다.

**긴 메서드의 단점**
- 이해하는 데 많은 시간이 걸린다.
- 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
- 메서드 로직 중 일부만 수정하더라도 나머지 부분에서 버그가 발생할 확률이 높다.
- 로직이 일부만 재사용하기 어렵다. = 코드 중복이 발생할 가능성이 크다. 

### chapter6. 메시지와 인터페이스
#### : **퍼블릭 인터페이스 (객체가 수신하는 메세지)** 를 만드는 데 도움이 되는 설계의 원칙과 기법

> 💡 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 **객체**를 지향해야 한다. 즉, 객체가 수행하는 **책임**에 초점을 맞춰야한다는 말이다.

#### 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
- 디미터 법칙
    - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것
    - '도트(.)'를 이용해 메시지 전송을 표현하는 언어에서 오직 하나의 도트만 사용하라라는 의미
        - 이 때, **객체의 내부 구조**를 노출하고 있는 경우에만 해당된다. 
    - 오직 인접한 이웃하고만 말하라
    
    👉 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.
    
    👉 단지 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청하게 한다.
- 묻지말고 시켜라
    - 외부에서 상태를 변경하는 경우에 해당된다.
- 의도를 드러내는 인터페이스
    - 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것
    - **이름을 지을 때**는 '어떻게'하는 지가 아닌 **'무엇'** 을 하느냐에 따라 짓는 것이 좋다.
- 명령-쿼리 분리
    - "질문이 답변을 수정해서는 안된다."
    - **명령**은 상태를 변경할 수 있지만 상태를 변경해서는 안 된다. **쿼리**는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안된다.
    - 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.
        ```
        isSatisfied() 
        ````
      
        - 위의 메소드를 호출했는 데, 상태가 변한다면 ? 👉 굉장히 큰 혼란을 줄 수 있다.
        
    👉 **명령**과 **쿼리**를 분리함으로써, 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것이다.
    
    👉 **참조 투명성**의 장점을 제한적이나마 누릴 수 있다. (**참조 투명성**이란 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성을 의미한다.)
    👉 버그가 적고, 디버깅이 용이하며, **쿼리의 순서에 따라 실행 결과가 변하지 않는 코드**를 작성할 수 있다.
    
#### 원칙의 함정
**원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다.**

> 💡 **소프트웨어 설계에 법칙이란 존재하지 않는 것이다. 원칙을 맹신하지 마라.**
>
> 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라. 설계는 트레이드 오프 산물이다.
>소프트웨어 설계에 존재하는 몇 안되는 법칙 중 하나는 "경우에 따라 다르다"라는 사실을 명심하라.

### chapter7. 객체 분해
> 💡 새로운 타입을 빈번하게 추가해야 한다면 **객체지향의 클래스 구조**가 더 유용하다.
> 새로운 오퍼레이션을 빈번하게 추가해야 한다면 **추상 데이터 타입**을 선택하는 것이 현명한 판단이다.
> 변경의 축을 찾아라. 객체지향적인 접근법이 모든 경우에 올바른 해결 방법인 것은 아니다.